 // Exemple d'utilisation de la librarie RGBmatrixPanel

#include <RGBmatrixPanel.h>

RGBmatrixPanel matrix(A0, A1, A2, A3, 11, 10, 9, false, 64);

#define LD1R 2  // ALIAS DES LED ET DES BOUTON
#define LD1G 1
#define LD1B 0
#define LD2R 7
#define LD2G 6
#define LD2B 5
#define LD3R 4
#define LD3G 3
#define LD3B 2
#define BTNUP 2
#define BTNDOWN 7
#define BTNLEFT 1
#define BTNRIGTH 3
#define BTNA 6
#define BTNB 4
#define BTNC 5
#define CHANl 5
#define CHAN2 3
#define SW1 5

unsigned long dernierDeplacement = 0;
volatile int StartEncodeur = 0;

struct Segment {
  int x;
  int y;
};

#define Max_Taille 256

Segment snake[Max_Taille];
int longeur = 5;
int nourritureX = 10;
int nourritureY = 10;


enum Direction { Haut,
                 Bas,
                 Gauche,
                 Droite };
Direction direction = Haut;


enum class Gamestate {
  MainMenu,
  Parametre,
  Playing,
  Gameover,
  Exit
};

void Machine_A_Etat();

enum CurrentState { Menu,
                    Parametre,
                    Playing,
                    GameOver
};
CurrentState currentState = Menu;
void Machine_A_Etat() {


  switch (currentState) {
    case Menu:
      EtatMenu();
      break;
    case Parametre:
      EtatParametre();
      break;
    case Playing:
      EtatPlaying();
      break;
    case GameOver:
      EtatGameOver();
      break;
    default:
      break;
  }
}

void EtatMenu() {
  matrix.setCursor(9, 1);
  matrix.setTextColor(matrix.Color888(255, 255, 255));
  matrix.print("Snake2.0");
  if (lireBTNUP()) {
       matrix.fillScreen(0);
    currentState = Parametre;
    delay(200);
  }
  if (lireBTNDOWN()) {
       matrix.fillScreen(0);
    currentState = Playing;
    delay(200);
  }
}
void EtatPlaying() {



  if (lireBTNUP() && direction != Bas) direction = Haut;
  if (lireBTNDOWN() && direction != Haut) direction = Bas;
  if (lireBTNLEFT() && direction != Droite) direction = Gauche;
  if (lireBTNRIGTH() && direction != Gauche) direction = Droite;
 
  if (millis() - dernierDeplacement > 250) {
    dernierDeplacement = millis();
      matrix.fillScreen(0);
    for (int i = longeur - 1; i > 0; i--) {
      snake[i] = snake[i - 1];
    }
    switch (direction) {
      case Haut: snake[0].y--; break;
      case Bas: snake[0].y++; break;
      case Gauche: snake[0].x--; break;
      case Droite: snake[0].x++; break;
    }
    if (snake[0].x < 0 || snake[0].x >= 63 || snake[0].y <= 0 || snake[0].y >= 31) {
      currentState = GameOver;
      return;
    }
    for (int i = 0; i < longeur; i++) {
      matrix.drawPixel(snake[i].x, snake[i].y, matrix.Color888(0, 255, 0));
    }
    for (int x = 0; x < 64; x++) {
      matrix.drawPixel(x, 0, matrix.Color888(255, 0, 0));
      matrix.drawPixel(x, 31, matrix.Color888(255, 0, 0));
    }
    for (int y = 0; y < 32; y++) {
      matrix.drawPixel(0, y, matrix.Color888(255, 0, 0));
      matrix.drawPixel(63, y, matrix.Color888(255, 0, 0));
    }
  }
}
void EtatParametre() {
 
  matrix.setCursor(5, 1);
  matrix.setTextColor(matrix.Color888(255, 255, 0));
  matrix.print("Parametre");
}

void EtatGameOver() {
  matrix.setCursor(5, 5);
  matrix.setTextColor(matrix.Color888(255, 0, 0));
  matrix.print("GAME OVER");
  if (lireBTNC()) {
    matrix.fillScreen(0);
    resetGame();
    currentState = Menu;
    delay(200);
  }
}

void resetGame(){
 longeur = 5;
 direction = Haut;
 snake[0].x = 64 / 2;
 snake[0].y = 32 / 2;
 for (int i = 0; i < longeur; i++) {
  snake[i].x = snake[0].x -i;
  snake[i].y = snake[0].y;

 }
 nourritureX = random(1,63);
 nourritureY = random(1,31);
}
void EncodeurInterruption() {
  if (PINE & (1 << CHAN2)) {
    StartEncodeur++;
  } else {
    StartEncodeur--;
  }
}
void ctrlLD1R(unsigned char etat) {
  if (etat) {
    PORTG |= (1 << LD1R);
  } else {
    PORTG &= ~(1 << LD1R);
  }
}
void ctrlLD1B(unsigned char etat) {
  if (etat) {
    PORTG |= (1 << LD1B);
  } else {
    PORTG &= ~(1 << LD1B);
  }
}
void ctrlLD1G(unsigned char etat) {
  if (etat) {
    PORTG |= (1 << LD1G);
  } else {
    PORTG &= ~(1 << LD1G);
  }
}
void ctrlLD2R(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD2R);
  } else {
    PORTL &= ~(1 << LD2R);
  }
}
void ctrlLD2B(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD2B);
  } else {
    PORTL &= ~(1 << LD2B);
  }
}
void ctrlLD2G(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD2G);
  } else {
    PORTL &= ~(1 << LD2G);
  }
}
void ctrlLD3R(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD3R);
  } else {
    PORTL &= ~(1 << LD3R);
  }
}
void ctrlLD3B(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD3B);
  } else {
    PORTL &= ~(1 << LD3B);
  }
}
void ctrlLD3G(unsigned char etat) {
  if (etat) {
    PORTL |= (1 << LD3G);
  } else {
    PORTL &= ~(1 << LD3G);
  }
}
unsigned char lireBTNUP() {
  return ((PINC & (1 << BTNUP)) == 0);
}
unsigned char lireBTNLEFT() {
  return ((PINC & (1 << BTNLEFT)) == 0);
}
unsigned char lireBTNDOWN() {
  return ((PINC & (1 << BTNDOWN)) == 0);
}
unsigned char lireBTNRIGTH() {
  return ((PINC & (1 << BTNRIGTH)) == 0);
}
unsigned char lireSW1() {
  return ((PING & (1 << SW1)) == 0);
}
unsigned char lireBTNC() {
  return ((PINC & (1 << BTNC)) == 0);
}

void setup() {
  matrix.begin();
  Serial.begin(9600);
  snake[0].x = 64 / 2;
  snake[0].y = 32 / 2;
  for (int i = 0; i < longeur; i++) {
    snake[i].x = snake[0].x - i;
    snake[i].y = snake[0].y;
  }
  randomSeed(analogRead(0));
  nourritureX = random(1, 63);
  nourritureY = random(1, 31);
  DDRE = 0XD7;   //LES BIT DE L ENCODEUR SONT A 0 POUR ENTRE
  DDRG = 0X07;   //LES BIT LED1 A 1 POUR SORTIE ET SW1 ENCODEUR A 0 POUR ENTRE
  DDRL = 0XFC;   // LES BIT LED 2 ET 3 A 1 POUR SORTIE
  DDRC = 0X01;   //LES BIT RESTE A 0 / POUR ENTRÉE RESTE A 1
  PORTC = 0XFF;  //PULL UP DES BIT 0 QUI SONT EENTRÉE
  PORTG = 0X20;  //PULL UP DU BOUTON SW1
  attachInterrupt(4, EncodeurInterruption, CHANGE);
}
void dessin() {
  matrix.setTextSize(1);
  matrix.setTextWrap(false);
  matrix.setCursor(9, 1);
  matrix.setTextColor(matrix.Color888(255, 255, 255));
  matrix.print("snake2.0");
}





void loop() {
  //validationLED();
  validationBTN();
  Machine_A_Etat();
  //dessin();
}

void validationLED() {
  ctrlLD1R(1);
  delay(1000);
  ctrlLD1R(0);
  delay(1000);
  ctrlLD2B(1);
  delay(1000);
  ctrlLD2B(0);
  delay(1000);
  ctrlLD3G(1);
  delay(1000);
  ctrlLD3G(0);
}
void validationBTN() {

  ctrlLD3R(lireBTNUP());
  ctrlLD1B(lireBTNDOWN());
  ctrlLD1G(lireBTNLEFT());
  ctrlLD2R(lireBTNRIGTH());
}
